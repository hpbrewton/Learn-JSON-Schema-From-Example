var cov_123qrjdv8z=function(){var path="/Users/hb/latlib/jsserver/javascript-algorithms/src/algorithms/graph/kruskal/kruskal.js";var hash="3396372f177766cc1466af6265b3b825906fb335";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/Users/hb/latlib/jsserver/javascript-algorithms/src/algorithms/graph/kruskal/kruskal.js",statementMap:{"0":{start:{line:12,column:2},end:{line:14,column:3}},"1":{start:{line:13,column:4},end:{line:13,column:78}},"2":{start:{line:17,column:30},end:{line:17,column:41}},"3":{start:{line:20,column:27},end:{line:32,column:3}},"4":{start:{line:26,column:6},end:{line:28,column:7}},"5":{start:{line:27,column:8},end:{line:27,column:17}},"6":{start:{line:30,column:6},end:{line:30,column:61}},"7":{start:{line:33,column:22},end:{line:33,column:79}},"8":{start:{line:36,column:22},end:{line:36,column:57}},"9":{start:{line:36,column:37},end:{line:36,column:57}},"10":{start:{line:37,column:22},end:{line:37,column:50}},"11":{start:{line:39,column:2},end:{line:41,column:5}},"12":{start:{line:40,column:4},end:{line:40,column:37}},"13":{start:{line:47,column:2},end:{line:59,column:3}},"14":{start:{line:47,column:23},end:{line:47,column:24}},"15":{start:{line:49,column:24},end:{line:49,column:46}},"16":{start:{line:52,column:4},end:{line:58,column:5}},"17":{start:{line:54,column:6},end:{line:54,column:72}},"18":{start:{line:57,column:6},end:{line:57,column:47}},"19":{start:{line:61,column:2},end:{line:61,column:29}}},fnMap:{"0":{name:"kruskal",decl:{start:{line:9,column:24},end:{line:9,column:31}},loc:{start:{line:9,column:39},end:{line:62,column:1}},line:9},"1":{name:"(anonymous_1)",decl:{start:{line:25,column:21},end:{line:25,column:22}},loc:{start:{line:25,column:49},end:{line:31,column:5}},line:25},"2":{name:"(anonymous_2)",decl:{start:{line:36,column:22},end:{line:36,column:23}},loc:{start:{line:36,column:37},end:{line:36,column:57}},line:36},"3":{name:"(anonymous_3)",decl:{start:{line:39,column:33},end:{line:39,column:34}},loc:{start:{line:39,column:50},end:{line:41,column:3}},line:39}},branchMap:{"0":{loc:{start:{line:12,column:2},end:{line:14,column:3}},type:"if",locations:[{start:{line:12,column:2},end:{line:14,column:3}},{start:{line:12,column:2},end:{line:14,column:3}}],line:12},"1":{loc:{start:{line:26,column:6},end:{line:28,column:7}},type:"if",locations:[{start:{line:26,column:6},end:{line:28,column:7}},{start:{line:26,column:6},end:{line:28,column:7}}],line:26},"2":{loc:{start:{line:30,column:13},end:{line:30,column:60}},type:"cond-expr",locations:[{start:{line:30,column:54},end:{line:30,column:56}},{start:{line:30,column:59},end:{line:30,column:60}}],line:30},"3":{loc:{start:{line:52,column:4},end:{line:58,column:5}},type:"if",locations:[{start:{line:52,column:4},end:{line:58,column:5}},{start:{line:52,column:4},end:{line:58,column:5}}],line:52}},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0,"18":0,"19":0},f:{"0":0,"1":0,"2":0,"3":0},b:{"0":[0,0],"1":[0,0],"2":[0,0],"3":[0,0]},_coverageSchema:"43e27e138ebf9cfc5966b082cf9a028302ed4184",hash:"3396372f177766cc1466af6265b3b825906fb335"};var coverage=global[gcv]||(global[gcv]={});if(coverage[path]&&coverage[path].hash===hash){return coverage[path];}return coverage[path]=coverageData;}();import Graph from'../../../data-structures/graph/Graph';import QuickSort from'../../sorting/quick-sort/QuickSort';import DisjointSet from'../../../data-structures/disjoint-set/DisjointSet';/**
 * @param {Graph} graph
 * @return {Graph}
 */export default function kruskal(graph){cov_123qrjdv8z.f[0]++;cov_123qrjdv8z.s[0]++;// It should fire error if graph is directed since the algorithm works only
// for undirected graphs.
if(graph.isDirected){cov_123qrjdv8z.b[0][0]++;cov_123qrjdv8z.s[1]++;throw new Error('Kruskal\'s algorithms works only for undirected graphs');}else{cov_123qrjdv8z.b[0][1]++;}// Init new graph that will contain minimum spanning tree of original graph.
const minimumSpanningTree=(cov_123qrjdv8z.s[2]++,new Graph());// Sort all graph edges in increasing order.
const sortingCallbacks=(cov_123qrjdv8z.s[3]++,{/**
     * @param {GraphEdge} graphEdgeA
     * @param {GraphEdge} graphEdgeB
     */compareCallback:(graphEdgeA,graphEdgeB)=>{cov_123qrjdv8z.f[1]++;cov_123qrjdv8z.s[4]++;if(graphEdgeA.weight===graphEdgeB.weight){cov_123qrjdv8z.b[1][0]++;cov_123qrjdv8z.s[5]++;return 1;}else{cov_123qrjdv8z.b[1][1]++;}cov_123qrjdv8z.s[6]++;return graphEdgeA.weight<=graphEdgeB.weight?(cov_123qrjdv8z.b[2][0]++,-1):(cov_123qrjdv8z.b[2][1]++,1);}});const sortedEdges=(cov_123qrjdv8z.s[7]++,new QuickSort(sortingCallbacks).sort(graph.getAllEdges()));// Create disjoint sets for all graph vertices.
cov_123qrjdv8z.s[8]++;const keyCallback=graphVertex=>{cov_123qrjdv8z.f[2]++;cov_123qrjdv8z.s[9]++;return graphVertex.getKey();};const disjointSet=(cov_123qrjdv8z.s[10]++,new DisjointSet(keyCallback));cov_123qrjdv8z.s[11]++;graph.getAllVertices().forEach(graphVertex=>{cov_123qrjdv8z.f[3]++;cov_123qrjdv8z.s[12]++;disjointSet.makeSet(graphVertex);});// Go through all edges started from the minimum one and try to add them
// to minimum spanning tree. The criteria of adding the edge would be whether
// it is forms the cycle or not (if it connects two vertices from one disjoint
// set or not).
cov_123qrjdv8z.s[13]++;for(let edgeIndex=(cov_123qrjdv8z.s[14]++,0);edgeIndex<sortedEdges.length;edgeIndex+=1){/** @var {GraphEdge} currentEdge */const currentEdge=(cov_123qrjdv8z.s[15]++,sortedEdges[edgeIndex]);// Check if edge forms the cycle. If it does then skip it.
cov_123qrjdv8z.s[16]++;if(!disjointSet.inSameSet(currentEdge.startVertex,currentEdge.endVertex)){cov_123qrjdv8z.b[3][0]++;cov_123qrjdv8z.s[17]++;// Unite two subsets into one.
disjointSet.union(currentEdge.startVertex,currentEdge.endVertex);// Add this edge to spanning tree.
cov_123qrjdv8z.s[18]++;minimumSpanningTree.addEdge(currentEdge);}else{cov_123qrjdv8z.b[3][1]++;}}cov_123qrjdv8z.s[19]++;return minimumSpanningTree;}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYi9sYXRsaWIvanNzZXJ2ZXIvamF2YXNjcmlwdC1hbGdvcml0aG1zL3NyYy9hbGdvcml0aG1zL2dyYXBoL2tydXNrYWwva3J1c2thbC5qcyJdLCJuYW1lcyI6WyJHcmFwaCIsIlF1aWNrU29ydCIsIkRpc2pvaW50U2V0Iiwia3J1c2thbCIsImdyYXBoIiwiaXNEaXJlY3RlZCIsIkVycm9yIiwibWluaW11bVNwYW5uaW5nVHJlZSIsInNvcnRpbmdDYWxsYmFja3MiLCJjb21wYXJlQ2FsbGJhY2siLCJncmFwaEVkZ2VBIiwiZ3JhcGhFZGdlQiIsIndlaWdodCIsInNvcnRlZEVkZ2VzIiwic29ydCIsImdldEFsbEVkZ2VzIiwia2V5Q2FsbGJhY2siLCJncmFwaFZlcnRleCIsImdldEtleSIsImRpc2pvaW50U2V0IiwiZ2V0QWxsVmVydGljZXMiLCJmb3JFYWNoIiwibWFrZVNldCIsImVkZ2VJbmRleCIsImxlbmd0aCIsImN1cnJlbnRFZGdlIiwiaW5TYW1lU2V0Iiwic3RhcnRWZXJ0ZXgiLCJlbmRWZXJ0ZXgiLCJ1bmlvbiIsImFkZEVkZ2UiXSwibWFwcGluZ3MiOiIydkdBQUEsTUFBT0EsQ0FBQUEsS0FBUCxLQUFrQixzQ0FBbEIsQ0FDQSxNQUFPQyxDQUFBQSxTQUFQLEtBQXNCLG9DQUF0QixDQUNBLE1BQU9DLENBQUFBLFdBQVAsS0FBd0IsbURBQXhCLENBRUE7OztHQUlBLGNBQWUsU0FBU0MsQ0FBQUEsT0FBVCxDQUFpQkMsS0FBakIsQ0FBd0IsNkNBQ3JDO0FBQ0E7QUFDQSxHQUFJQSxLQUFLLENBQUNDLFVBQVYsQ0FBc0IsZ0RBQ3BCLEtBQU0sSUFBSUMsQ0FBQUEsS0FBSixDQUFVLHdEQUFWLENBQU4sQ0FDRCxDQUZELCtCQUlBO0FBQ0EsS0FBTUMsQ0FBQUEsbUJBQW1CLHdCQUFHLEdBQUlQLENBQUFBLEtBQUosRUFBSCxDQUF6QixDQUVBO0FBQ0EsS0FBTVEsQ0FBQUEsZ0JBQWdCLHdCQUFHLENBQ3ZCOzs7T0FJQUMsZUFBZSxDQUFFLENBQUNDLFVBQUQsQ0FBYUMsVUFBYixHQUE0Qiw2Q0FDM0MsR0FBSUQsVUFBVSxDQUFDRSxNQUFYLEdBQXNCRCxVQUFVLENBQUNDLE1BQXJDLENBQTZDLGdEQUMzQyxNQUFPLEVBQVAsQ0FDRCxDQUZELCtCQUQyQyxzQkFLM0MsTUFBT0YsQ0FBQUEsVUFBVSxDQUFDRSxNQUFYLEVBQXFCRCxVQUFVLENBQUNDLE1BQWhDLDJCQUF5QyxDQUFDLENBQTFDLDRCQUE4QyxDQUE5QyxDQUFQLENBQ0QsQ0FYc0IsQ0FBSCxDQUF0QixDQWFBLEtBQU1DLENBQUFBLFdBQVcsd0JBQUcsR0FBSVosQ0FBQUEsU0FBSixDQUFjTyxnQkFBZCxFQUFnQ00sSUFBaEMsQ0FBcUNWLEtBQUssQ0FBQ1csV0FBTixFQUFyQyxDQUFILENBQWpCLENBRUE7QUExQnFDLHNCQTJCckMsS0FBTUMsQ0FBQUEsV0FBVyxDQUFHQyxXQUFXLEVBQUksbURBQUFBLENBQUFBLFdBQVcsQ0FBQ0MsTUFBWixHQUFvQixDQUF2RCxDQUNBLEtBQU1DLENBQUFBLFdBQVcseUJBQUcsR0FBSWpCLENBQUFBLFdBQUosQ0FBZ0JjLFdBQWhCLENBQUgsQ0FBakIsQ0E1QnFDLHVCQThCckNaLEtBQUssQ0FBQ2dCLGNBQU4sR0FBdUJDLE9BQXZCLENBQWdDSixXQUFELEVBQWlCLDhDQUM5Q0UsV0FBVyxDQUFDRyxPQUFaLENBQW9CTCxXQUFwQixFQUNELENBRkQsRUFJQTtBQUNBO0FBQ0E7QUFDQTtBQXJDcUMsdUJBc0NyQyxJQUFLLEdBQUlNLENBQUFBLFNBQVMseUJBQUcsQ0FBSCxDQUFsQixDQUF3QkEsU0FBUyxDQUFHVixXQUFXLENBQUNXLE1BQWhELENBQXdERCxTQUFTLEVBQUksQ0FBckUsQ0FBd0UsQ0FDdEUsbUNBQ0EsS0FBTUUsQ0FBQUEsV0FBVyx5QkFBR1osV0FBVyxDQUFDVSxTQUFELENBQWQsQ0FBakIsQ0FFQTtBQUpzRSx1QkFLdEUsR0FBSSxDQUFDSixXQUFXLENBQUNPLFNBQVosQ0FBc0JELFdBQVcsQ0FBQ0UsV0FBbEMsQ0FBK0NGLFdBQVcsQ0FBQ0csU0FBM0QsQ0FBTCxDQUE0RSxpREFDMUU7QUFDQVQsV0FBVyxDQUFDVSxLQUFaLENBQWtCSixXQUFXLENBQUNFLFdBQTlCLENBQTJDRixXQUFXLENBQUNHLFNBQXZELEVBRUE7QUFKMEUsdUJBSzFFckIsbUJBQW1CLENBQUN1QixPQUFwQixDQUE0QkwsV0FBNUIsRUFDRCxDQU5ELCtCQU9ELENBbERvQyx1QkFvRHJDLE1BQU9sQixDQUFBQSxtQkFBUCxDQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdyYXBoIGZyb20gJy4uLy4uLy4uL2RhdGEtc3RydWN0dXJlcy9ncmFwaC9HcmFwaCc7XG5pbXBvcnQgUXVpY2tTb3J0IGZyb20gJy4uLy4uL3NvcnRpbmcvcXVpY2stc29ydC9RdWlja1NvcnQnO1xuaW1wb3J0IERpc2pvaW50U2V0IGZyb20gJy4uLy4uLy4uL2RhdGEtc3RydWN0dXJlcy9kaXNqb2ludC1zZXQvRGlzam9pbnRTZXQnO1xuXG4vKipcbiAqIEBwYXJhbSB7R3JhcGh9IGdyYXBoXG4gKiBAcmV0dXJuIHtHcmFwaH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ga3J1c2thbChncmFwaCkge1xuICAvLyBJdCBzaG91bGQgZmlyZSBlcnJvciBpZiBncmFwaCBpcyBkaXJlY3RlZCBzaW5jZSB0aGUgYWxnb3JpdGhtIHdvcmtzIG9ubHlcbiAgLy8gZm9yIHVuZGlyZWN0ZWQgZ3JhcGhzLlxuICBpZiAoZ3JhcGguaXNEaXJlY3RlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignS3J1c2thbFxcJ3MgYWxnb3JpdGhtcyB3b3JrcyBvbmx5IGZvciB1bmRpcmVjdGVkIGdyYXBocycpO1xuICB9XG5cbiAgLy8gSW5pdCBuZXcgZ3JhcGggdGhhdCB3aWxsIGNvbnRhaW4gbWluaW11bSBzcGFubmluZyB0cmVlIG9mIG9yaWdpbmFsIGdyYXBoLlxuICBjb25zdCBtaW5pbXVtU3Bhbm5pbmdUcmVlID0gbmV3IEdyYXBoKCk7XG5cbiAgLy8gU29ydCBhbGwgZ3JhcGggZWRnZXMgaW4gaW5jcmVhc2luZyBvcmRlci5cbiAgY29uc3Qgc29ydGluZ0NhbGxiYWNrcyA9IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0dyYXBoRWRnZX0gZ3JhcGhFZGdlQVxuICAgICAqIEBwYXJhbSB7R3JhcGhFZGdlfSBncmFwaEVkZ2VCXG4gICAgICovXG4gICAgY29tcGFyZUNhbGxiYWNrOiAoZ3JhcGhFZGdlQSwgZ3JhcGhFZGdlQikgPT4ge1xuICAgICAgaWYgKGdyYXBoRWRnZUEud2VpZ2h0ID09PSBncmFwaEVkZ2VCLndlaWdodCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdyYXBoRWRnZUEud2VpZ2h0IDw9IGdyYXBoRWRnZUIud2VpZ2h0ID8gLTEgOiAxO1xuICAgIH0sXG4gIH07XG4gIGNvbnN0IHNvcnRlZEVkZ2VzID0gbmV3IFF1aWNrU29ydChzb3J0aW5nQ2FsbGJhY2tzKS5zb3J0KGdyYXBoLmdldEFsbEVkZ2VzKCkpO1xuXG4gIC8vIENyZWF0ZSBkaXNqb2ludCBzZXRzIGZvciBhbGwgZ3JhcGggdmVydGljZXMuXG4gIGNvbnN0IGtleUNhbGxiYWNrID0gZ3JhcGhWZXJ0ZXggPT4gZ3JhcGhWZXJ0ZXguZ2V0S2V5KCk7XG4gIGNvbnN0IGRpc2pvaW50U2V0ID0gbmV3IERpc2pvaW50U2V0KGtleUNhbGxiYWNrKTtcblxuICBncmFwaC5nZXRBbGxWZXJ0aWNlcygpLmZvckVhY2goKGdyYXBoVmVydGV4KSA9PiB7XG4gICAgZGlzam9pbnRTZXQubWFrZVNldChncmFwaFZlcnRleCk7XG4gIH0pO1xuXG4gIC8vIEdvIHRocm91Z2ggYWxsIGVkZ2VzIHN0YXJ0ZWQgZnJvbSB0aGUgbWluaW11bSBvbmUgYW5kIHRyeSB0byBhZGQgdGhlbVxuICAvLyB0byBtaW5pbXVtIHNwYW5uaW5nIHRyZWUuIFRoZSBjcml0ZXJpYSBvZiBhZGRpbmcgdGhlIGVkZ2Ugd291bGQgYmUgd2hldGhlclxuICAvLyBpdCBpcyBmb3JtcyB0aGUgY3ljbGUgb3Igbm90IChpZiBpdCBjb25uZWN0cyB0d28gdmVydGljZXMgZnJvbSBvbmUgZGlzam9pbnRcbiAgLy8gc2V0IG9yIG5vdCkuXG4gIGZvciAobGV0IGVkZ2VJbmRleCA9IDA7IGVkZ2VJbmRleCA8IHNvcnRlZEVkZ2VzLmxlbmd0aDsgZWRnZUluZGV4ICs9IDEpIHtcbiAgICAvKiogQHZhciB7R3JhcGhFZGdlfSBjdXJyZW50RWRnZSAqL1xuICAgIGNvbnN0IGN1cnJlbnRFZGdlID0gc29ydGVkRWRnZXNbZWRnZUluZGV4XTtcblxuICAgIC8vIENoZWNrIGlmIGVkZ2UgZm9ybXMgdGhlIGN5Y2xlLiBJZiBpdCBkb2VzIHRoZW4gc2tpcCBpdC5cbiAgICBpZiAoIWRpc2pvaW50U2V0LmluU2FtZVNldChjdXJyZW50RWRnZS5zdGFydFZlcnRleCwgY3VycmVudEVkZ2UuZW5kVmVydGV4KSkge1xuICAgICAgLy8gVW5pdGUgdHdvIHN1YnNldHMgaW50byBvbmUuXG4gICAgICBkaXNqb2ludFNldC51bmlvbihjdXJyZW50RWRnZS5zdGFydFZlcnRleCwgY3VycmVudEVkZ2UuZW5kVmVydGV4KTtcblxuICAgICAgLy8gQWRkIHRoaXMgZWRnZSB0byBzcGFubmluZyB0cmVlLlxuICAgICAgbWluaW11bVNwYW5uaW5nVHJlZS5hZGRFZGdlKGN1cnJlbnRFZGdlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWluaW11bVNwYW5uaW5nVHJlZTtcbn1cbiJdfQ==